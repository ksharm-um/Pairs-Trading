# -*- coding: utf-8 -*-
"""Karan_Sharma_PairsTrading.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rsvXzMqw-zj3PHKnNU4fa7uYLPgeM4Ca
"""

import numpy as np
import pandas as pd
import statsmodels
import statsmodels.api as sm
from statsmodels.tsa.stattools import coint, adfuller

import matplotlib.pyplot as plt
import seaborn as sns; sns.set(style="whitegrid")
import yfinance as yf
import datetime as dt
import pandas_datareader
from pandas_datareader import data as pdr

# Import the datetime module (often abbreviated as 'dt') from the 'datetime' library
# 'dt' will be used to handle dates and times in the code
start = dt.datetime(2022, 1, 1)  # Define the start date for data collection (January 1, 2022)
end = dt.datetime(2025, 1, 1)    # Define the end date for data collection (January 1, 2025)

# List of stock ticker symbols (e.g., TXN = Texas Instruments, NVDA = Nvidia, etc.)
#tickers = ["TXN", "NVDA", "TM","GM", "TSM", "AMD", "TSLA", "INTC", "QCOM", "VWAGY",
 #          "AAPL", "BA", "RTX", "LMT", "SONY"]
tickers = ["PWR", "EME", "FIX","BBCP", "ESOA", "STRL","ROAD", "FLR","KBR", "EXPO"]

# Download historical stock data using the 'yfinance' (yf) library
# Specifically, download the 'Close' price for each stock in the 'tickers' list
# The data will be fetched from the start date (2019-01-01) to the end date (2024-02-01)
df = yf.download(tickers, start, end)["Close"]
#df.isnull().values.any()
df.replace([np.inf, -np.inf], np.nan, inplace=True)
df = df.dropna()

# Display the last few rows of the DataFrame to verify the data (this shows the most recent data points)
df.tail()

# Function to find cointegrated pairs of stocks from the given data.
# Cointegration helps identify pairs of stocks whose prices move together in the long term,
# which is a key concept in pairs trading.
def find_cointigrated_pairs(data, tickers):

    # n stores the number of tickers (stocks) for which we want to test cointegration.
    n = len(tickers)

    # Initialize two matrices of size n x n with zeros and ones respectively:
    # score_matrix will hold the cointegration scores.
    # p_matrix will hold the p-values (probability values) of the tests.
    score_matrix = np.zeros((n, n))  # Scores will indicate the strength of the cointegration.
    p_matrix = np.ones((n, n))       # p-values will help assess statistical significance.

    # keys is a list of the column names from the data DataFrame,
    # which correspond to the ticker symbols of the stocks.
    keys = data.columns.tolist()

    # p_pairs will store the pairs of tickers that are cointegrated.
    p_pairs = []

    # Loop through each possible pair of tickers (without repeating combinations).
    for i in range(len(tickers)):
        for j in range(i + 1, len(tickers)):
            # ticker1 and ticker2 represent the current pair of stocks being compared.
            ticker1 = keys[i]
            ticker2 = keys[j]

            # Perform the cointegration test using the 'coint' function from the 'statsmodels' library.
            # This function returns three values: the cointegration score, the p-value, and critical values.
            result = coint(data[ticker1], data[ticker2])

            # Extract the cointegration score (used for analysis) and p-value (used for statistical significance).
            score = result[0]    # The test statistic for the cointegration test.
            pvalue = result[1]   # The p-value indicating the likelihood that the pair is cointegrated.

            # Store the p-value in the p_matrix at position [i, j].
            p_matrix[i, j] = pvalue

            # Store the cointegration score in the score_matrix at position [i, j].
            score_matrix[i, j] = score

            # If the p-value is less than or equal to 0.05 (indicating statistical significance at 5% level),
            # consider the pair to be cointegrated and add the pair to p_pairs.
            if pvalue <= 0.05:
                p_pairs.append((keys[i], keys[j]))

    # Return three values:
    # score_matrix: Contains the cointegration scores between all pairs.
    # p_matrix: Contains the p-values between all pairs.
    # p_pairs: List of stock pairs that are likely cointegrated (p-value <= 0.05).
    return score_matrix, p_matrix, p_pairs

# Call the 'find_cointigrated_pairs' function to find the cointegrated stock pairs.
# It returns three things:
# - 'score': a matrix of cointegration scores between all pairs of stocks.
# - 'pvalues': a matrix of p-values for the cointegration tests.
# - 'pairs': a list of stock pairs that are likely cointegrated (with p-values <= 0.05).
score, pvalues, pairs = find_cointigrated_pairs(df, tickers)

# Print out the list of cointegrated pairs that were found.
print(pairs)

# Create a new plot using Matplotlib to visualize the cointegration p-values.
# fig, ax is the figure and axes of the plot, where figsize sets the size of the plot.
fig, ax = plt.subplots(figsize=(10,10))

# Use Seaborn's heatmap function to create a visual representation of the p-values matrix.
# xticklabels and yticklabels display the names of the stocks on both axes.
# cmap='RdYlGn_r' sets the color palette for the heatmap (red to yellow to green, reversed).
# mask = (pvalues >= 0.05) hides (masks) any cells in the matrix where the p-value is >= 0.05
# (i.e., pairs that are not statistically significant and thus not cointegrated).
sns.heatmap(pvalues,
            xticklabels=df.columns,  # Label the columns (x-axis) with stock tickers
            yticklabels=df.columns,  # Label the rows (y-axis) with stock tickers
            cmap='RdYlGn_r',         # Set the color map (red = non-cointegrated, green = cointegrated)
            mask=(pvalues >= 0.05)   # Mask (hide) values with p-values greater than or equal to 0.05
           )



"""Score Matrix:
int to zeros
P value Matrix:
initalize to ones
Engle Granger:
Nested for loop I + 1:

Graphs the Spread of both stocks
"""

# Extract the closing price series for Sony (S1) and TSMC (S2) from the DataFrame 'df'.
S1 = df["ESOA"]  # S1 is the price series for Sony (stock ticker: SONY)
S2 = df["ROAD"]   # S2 is the price series for Taiwan Semiconductor Manufacturing Co. (TSMC) (stock ticker: TSM)

# Add a constant (intercept term) to the Sony price series (S1) so it can be used in a linear regression model.
# This is necessary because the Ordinary Least Squares (OLS) model requires an intercept to fit the line properly.
S1 = sm.add_constant(S1)

# Fit an Ordinary Least Squares (OLS) regression model using the TSMC price series (S2) as the dependent variable
# and the Sony price series (S1) as the independent variable.
results = sm.OLS(S2, S1).fit()

# Extract the constant price series (the original Sony prices) for further use.
S1 = S1["ESOA"]

# Extract the regression coefficient (beta) for Sony from the OLS regression results.
# The 'b' value represents the sensitivity or relationship between the prices of TSMC (S2) and Sony (S1).
b = results.params["ESOA"]

# Calculate the "spread" between the two stocks.
# The spread is the difference between the actual price of TSMC (S2) and the predicted price of TSMC
# based on its relationship to Sony (b * S1). This spread represents the deviation of the pair from their
# equilibrium (the "cointegrated" relationship).
spread = S2 - b * S1

# Plot the spread (the deviation between the two stocks) over time using Matplotlib.
spread.plot(figsize=(12,6))  # Create a plot of the spread with a figure size of 12x6 inches.

# Draw a horizontal line at the mean of the spread (the equilibrium level of the spread) to show
# where the stocks should revert to if they are cointegrated.
plt.axhline(spread.mean(), color='black')  # The mean spread (the equilibrium level) is plotted as a black line.

# Set the x-axis limits to display the spread data between January 1, 2019, and February 11, 2024.
plt.xlim('2022-01-01', '2024-11-03')

# Add a legend to the plot to label the line as 'Spread'.
plt.legend(['Spread'])

"""Plot the Ratio

"""

# Calculate the price ratio between Sony (S1) and TSMC (S2).
# This represents how many shares of TSMC are equivalent to one share of Sony.
# A rising ratio indicates Sony is becoming more expensive relative to TSMC, and a falling ratio means the opposite.
ratio = S1 / S2

# Plot the price ratio over time.
# This shows how the relative prices of Sony and TSMC change over the specified period.
ratio.plot(figsize=(12,6))  # Create a plot of the price ratio with a figure size of 12x6 inches.

# Draw a horizontal line at the mean of the price ratio (the equilibrium level of the ratio).
# This indicates where the price ratio tends to revert to over time if the stocks are mean-reverting.
plt.axhline(ratio.mean(), color='black')  # The mean price ratio is plotted as a black line (the equilibrium level).

# Set the x-axis limits to show the ratio data from the start date to the end date (as defined earlier in the code).
plt.xlim(start, end)  # Set the x-axis to match the time frame used in the dataset (from 2019-01-01 to 2024-02-01).

# Add a legend to the plot to label the line as 'Price Ratio'.
plt.legend(['Price Ratio'])

# Define a function to calculate the z-score of a given price series.
# The z-score measures how many standard deviations a data point is from the mean.
# It's calculated by subtracting the mean from each value and dividing by the standard deviation.
def zscore(series):
    return (series - series.mean()) / np.std(series)

# Plot the z-score of the price ratio between Sony and TSMC over time.
# The z-score helps us understand how far the current ratio deviates from its historical average.
zscore(ratio).plot(figsize=(12,6))  # Plot the z-score with a figure size of 12x6 inches.

# Draw a horizontal line at the mean of the z-score, which should be 0 because it's the normalized center point.
plt.axhline(zscore(ratio).mean())  # The mean z-score (expected to be 0) is plotted as a horizontal line.

# Draw a red horizontal line at a z-score of 1.0.
# This indicates one standard deviation above the mean, often used as an upper threshold in pairs trading.
plt.axhline(1.0, color='red')  # A z-score of 1.0 indicates the ratio is one standard deviation above the mean.

# Draw a green horizontal line at a z-score of -1.0.
# This indicates one standard deviation below the mean, often used as a lower threshold in pairs trading.
plt.axhline(-1.0, color='green')  # A z-score of -1.0 indicates the ratio is one standard deviation below the mean.

# Set the x-axis limits to match the time frame from the start date to the end date.
plt.xlim(start, end)  # Limit the plot to the time period from 2019-01-01 to 2024-02-01.

# Display the plot.
plt.show()

# Extract the closing price series for Intel (S3) and Lockheed Martin (S4) from the DataFrame 'df'.
S3 = df["BBCP"]  # S3 is the price series for Intel (stock ticker: INTC).
S4 = df["EXPO"]   # S4 is the price series for Lockheed Martin (stock ticker: LMT).

# Calculate the price ratio between Intel (S3) and Lockheed Martin (S4).
# This ratio shows how many shares of Lockheed Martin are equivalent to one share of Intel.
ratio = S3 / S4

# Plot the z-score of the price ratio between Intel and Lockheed Martin over time.
# The z-score tells us how far the current price ratio is from its historical mean in terms of standard deviations.
zscore(ratio).plot(figsize=(12,6))  # Plot the z-score with a figure size of 12x6 inches.

# Draw a horizontal line at the mean of the z-score, which should be 0 (the equilibrium level).
plt.axhline(zscore(ratio).mean())  # The mean z-score (expected to be 0) is plotted as a horizontal line.

# Draw a red horizontal line at a z-score of 1.0 to mark one standard deviation above the mean.
plt.axhline(1.0, color='red')  # A z-score of 1.0 indicates the ratio is one standard deviation above the mean.

# Draw a green horizontal line at a z-score of -1.0 to mark one standard deviation below the mean.
plt.axhline(-1.0, color='green')  # A z-score of -1.0 indicates the ratio is one standard deviation below the mean.

# Set the x-axis limits to match the time frame from the start date to the end date.
plt.xlim(start, end)  # Limit the plot to the time period from 2019-01-01 to 2024-02-01.

# Display the plot.
plt.show()

S5 = df["PWR"]
S6 = df["STRL"]
ratio = S5/S6

zscore(ratio).plot(figsize=(12,6))
plt.axhline(zscore(ratio).mean())
plt.axhline(1.0, color='red')
plt.axhline(-1.0, color='green')
plt.xlim(start, end)
plt.show()

# Calculate the price ratio between Sony (SONY) and TSMC (TSM).
# This gives the number of shares of TSMC that are equivalent to one share of Sony.
ratios = df['PWR'] / df['STRL']

# Print 80% of the total length of the 'ratios' series.
# This could be used to determine the size of a training set if you're splitting the data into training and testing sets.
print(len(ratios) * 0.8)  # Prints 80% of the total data points in the 'ratios' series.

# Print the total length (number of data points) in the 'ratios' series.
print(len(ratios))  # Prints the total number of data points in the 'ratios' series.

# Split the 'ratios' series into a training set and a testing set.

# The first 1151 data points (which is approximately 80% of the total) will be used for the training set.
train = ratios[:1151]  # This creates the training dataset from the first 1151 data points.

# The remaining data points (starting from index 1151 to the end) will be used for the testing set.
test = ratios[1151:]  # This creates the testing dataset from the remaining data points.

# Calculate a 5-day moving average of the price ratio between Sony and TSMC.
# This smooths the price ratio over a short time window to highlight short-term trends.
ratios_mavg5 = ratios.rolling(window=5, center=False).mean()

# Calculate a 60-day moving average of the price ratio.
# This is a longer-term moving average that highlights the general trend of the ratio.
ratios_mavg60 = ratios.rolling(window=60, center=False).mean()

# Calculate the rolling standard deviation of the price ratio over a 60-day window.
# The standard deviation is used to measure the volatility or spread of the ratio.
std_60 = ratios.rolling(window=60, center=False).std()

# Calculate the z-score using the 5-day moving average and the 60-day moving average.
# This shows how far the 5-day moving average is from the 60-day moving average in terms of standard deviations.
zscore_60_5 = (ratios_mavg5 - ratios_mavg60) / std_60

# Plot the original ratio and the moving averages for visual analysis.
plt.figure(figsize=(12, 6))  # Create a plot with a figure size of 12x6 inches.

# Plot the original price ratio between Sony and TSMC.
plt.plot(ratios.index, ratios.values)

# Plot the 5-day moving average of the price ratio to show short-term trends.
plt.plot(ratios_mavg5.index, ratios_mavg5.values)

# Plot the 60-day moving average of the price ratio to show longer-term trends.
plt.plot(ratios_mavg60.index, ratios_mavg60.values)

# Add a legend to distinguish between the original ratio, 5-day moving average, and 60-day moving average.
plt.legend(['Ratio', '5d Ratio MA', '60d Ratio MA'])

# Label the y-axis as "Ratio" to indicate that the plot shows the price ratio.
plt.ylabel('Ratio')

# Display the plot.
plt.show()

# Create a new plot with a specified figure size of 12x6 inches.
plt.figure(figsize=(12, 6))

# Plot the z-score of the rolling ratio (the difference between the 5-day and 60-day moving averages).
# This graph will show how the current short-term trend compares to the long-term trend in standard deviation units.
zscore_60_5.plot()

# Set the x-axis limits to match the defined time frame from the start date to the end date.
plt.xlim(start, end)  # Limit the plot to the time period from 2019-01-01 to 2024-02-01.

# Draw a horizontal line at y = 0, representing the mean of the z-scores.
# This line indicates where the z-score would be if the 5-day and 60-day moving averages were equal.
plt.axhline(0, color='black')  # A black line at the mean z-score (expected to be 0).

# Draw a red dashed horizontal line at y = 1.0 to mark one standard deviation above the mean.
# This line serves as a threshold for potential overbought conditions in pairs trading.
plt.axhline(1.0, color='red', linestyle='--')  # A red dashed line at z = 1.0.

# Draw a green dashed horizontal line at y = -1.0 to mark one standard deviation below the mean.
# This line serves as a threshold for potential oversold conditions in pairs trading.
plt.axhline(-1.0, color='green', linestyle='--')  # A green dashed line at z = -1.0.

# Add a legend to the plot to label the z-score and threshold lines.
plt.legend(['Rolling Ratio z-Score', 'Mean', '+1', '-1'])

# Display the plot.
plt.show()

# Create a new plot with a specified figure size of 12x6 inches.
plt.figure(figsize=(12, 6))

# Plot the training data for the price ratio starting from index 160 to provide a clear view of the signals.
train[160:].plot()  # This shows the historical price ratio over time, starting from a specific point.

# Create copies of the training data to store buy and sell signals.
buy = train.copy()  # This will hold the buy signals.
sell = train.copy()  # This will hold the sell signals.

# Set the buy signals to 0 where the z-score is greater than -1 (indicating a potential buy opportunity).
# This means we want to buy when the z-score indicates the ratio is approaching an oversold condition.
buy[zscore_60_5 > -1] = 0  # Buy signal: set to 0 where z-score is greater than -1.

# Set the sell signals to 0 where the z-score is less than 1 (indicating a potential sell opportunity).
# This means we want to sell when the z-score indicates the ratio is approaching an overbought condition.
sell[zscore_60_5 < 1] = 0  # Sell signal: set to 0 where z-score is less than 1.

# Plot the buy signals as green triangles (markers) on the graph.
buy[160:].plot(color='g', linestyle='None', marker='^')  # Green triangles indicate buy signals.

# Plot the sell signals as red triangles (markers) on the graph.
sell[160:].plot(color='r', linestyle='None', marker='^')  # Red triangles indicate sell signals.

# Get the current axis limits for x and y.
x1, x2, y1, y2 = plt.axis()

# Set the y-axis limits to match the minimum and maximum values of the ratios for better visualization.
plt.axis((x1, x2, ratios.min(), ratios.max()))  # Adjust y-axis to the range of the ratio values.

# Set the x-axis limits to the defined time frame from the start date to the end date.
plt.xlim(start, end)  # Limit the plot to the time period from 2019-01-01 to 2024-02-01.

# Add a legend to distinguish between the ratio, buy signals, and sell signals.
plt.legend(['Ratio', 'Buy Signal', 'Sell Signal'])

# Display the plot.
plt.show()

# Create a new plot with a specified figure size of 12x7 inches.
plt.figure(figsize=(12, 7))

# Select the first 1023 data points for SONY and TSM stocks for analysis.
S1 = df['PWR'].iloc[:1023]  # Stock prices for SONY.
S2 = df['STRL'].iloc[:1023]   # Stock prices for TSM.

# Plot the SONY stock prices starting from the 60th data point (for clarity).
S1[60:].plot(color='b')  # Plot SONY prices in blue.

# Plot the TSM stock prices starting from the 60th data point.
S2[60:].plot(color='c')  # Plot TSM prices in cyan.

# Initialize arrays to hold buy and sell quantities for the ratio trades.
buyR = 0 * S1.copy()  # Array to hold buy amounts for SONY.
sellR = 0 * S1.copy()  # Array to hold sell amounts for TSM.

# When a buy signal occurs (from the earlier calculation), we buy SONY and sell TSM.
buyR[buy != 0] = S1[buy != 0]  # Assign SONY prices where a buy signal is indicated.
sellR[buy != 0] = S2[buy != 0]  # Assign TSM prices where a buy signal is indicated.

# When a sell signal occurs, we sell SONY and buy TSM.
buyR[sell != 0] = S2[sell != 0]  # Assign TSM prices where a sell signal is indicated.
sellR[sell != 0] = S1[sell != 0]  # Assign SONY prices where a sell signal is indicated.

# Plot buy signals as green triangles on the graph.
buyR[60:].plot(color='g', linestyle='None', marker='^')  # Green triangles for buy signals.

# Plot sell signals as red triangles on the graph.
sellR[60:].plot(color='r', linestyle='None', marker='^')  # Red triangles for sell signals.

# Get the current axis limits for x and y.
x1, x2, y1, y2 = plt.axis()

# Adjust the y-axis to encompass the minimum and maximum stock prices of SONY and TSM.
plt.axis((x1, x2, min(S1.min(), S2.min()), max(S1.max(), S2.max())))

# Set the y-axis limits to provide a clear view of the stock prices.
plt.ylim(25, 145)  # Set y-axis limits for better visualization of stock price ranges.

# Set the x-axis limits to the defined time frame from the start date to the end date.
plt.xlim(start, end)  # Limit the plot to the time period from 2019-01-01 to 2024-02-01.

# Add a legend to distinguish between SONY, TSM, buy signals, and sell signals.
plt.legend(['PWR', 'STRL', 'Buy Signal', 'Sell Signal'])

# Display the plot.
plt.show()

def trade(S1, S2, window1, window2, starting_money):
    # If window length is 0, the algorithm doesn't make sense, so exit.
    if (window1 == 0) or (window2 == 0):
        return 0  # Early exit if window sizes are invalid.

   # Compute the rolling mean and rolling standard deviation of the price ratio.
    ratios = S1 / S2  # Calculate the price ratio between the two stocks.
    ma1 = ratios.rolling(window=window1, center=False).mean()  # Short-term moving average.
    ma2 = ratios.rolling(window=window2, center=False).mean()  # Long-term moving average.
    std = ratios.rolling(window=window2, center=False).std()  # Standard deviation over the long window.

    # Calculate the z-score to assess how far the current ratio deviates from its mean.
    zscore = (ma1 - ma2) / std  # Z-score for normalization of the ratio.

    # Simulate trading with the specified starting amount of money.
    money = starting_money  # Initialize the amount of money available for trading.
    countS1 = 0  # Track the number of shares held for stock S1 (SONY).
    countS2 = 0  # Track the number of shares held for stock S2 (TSM).

    # Iterate over the length of the ratios to simulate trading decisions.
    for i in range(len(ratios)):
        # Sell short if the z-score is less than -1 (indicating potential overbought condition).
        if zscore[i] < -1:
            money += S1[i] - S2[i] * ratios[i]  # Update money based on the trade.
            countS1 -= 1  # Decrease position in S1 (SONY).
            countS2 += ratios[i]  # Increase position in S2 (TSM).
            # print('Selling Ratio %s %s %s %s' % (money, ratios[i], countS1, countS2))

        # Buy long if the z-score is greater than 1 (indicating potential oversold condition).
        elif zscore[i] > 1:
            money -= S1[i] - S2[i] * ratios[i]  # Deduct money for the purchase.
            countS1 += 1  # Increase position in S1 (SONY).
            countS2 -= ratios[i]  # Decrease position in S2 (TSM).
            # print('Buying Ratio %s %s %s %s' % (money, ratios[i], countS1, countS2))

        # Clear positions if the z-score is between -0.75 and 0.75 (indicating neutrality).
        elif abs(zscore[i]) < 0.75:
            money += S1[i] * countS1 + S2[i] * countS2  # Liquidate positions.
            countS1 = 0  # Reset S1 position.
            countS2 = 0  # Reset S2 position.
            # print('Exit pos %s %s %s %s' % (money, ratios[i], countS1, countS2))

    # Final adjustment: cash out remaining positions at the last observed prices.
    money += S1[-1] * countS1 + S2[-1] * countS2
    # Calculate percentage change in the trading account.
    percentage_change = ((money - starting_money) / starting_money) * 100
    return percentage_change  # Return the overall percentage change in money.

trade(df['INTC'].iloc[1151:], df['LMT'].iloc[1151:], 34, 5, 10000)

trade(df['INTC'].iloc[1151:], df['LMT'].iloc[1151:], 120, 5, 1000)

trade(df['QCOM'].iloc[1151:], df['TSLA'].iloc[1151:], 120, 5, 10000)